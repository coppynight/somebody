<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
    <title>Voice Twin Mobile</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;500;700&family=Orbitron:wght@500;700&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        --bg0: #030612;
        --bg1: #0a1020;
        --bg2: #101a31;
        --line: rgba(135, 178, 247, 0.26);
        --text: #eaf3ff;
        --muted: #89a4cf;
        --cyan: #41e8ff;
        --blue: #4f74ff;
        --violet: #8d77ff;
        --mint: #5effbf;
        --danger: #cc6078;
      }

      * {
        box-sizing: border-box;
      }

      html,
      body {
        margin: 0;
        min-height: 100%;
      }

      body {
        min-height: 100vh;
        display: grid;
        place-items: center;
        padding: 14px;
        font-family: "Noto Sans SC", sans-serif;
        color: var(--text);
        background:
          radial-gradient(circle at 8% 6%, rgba(65, 232, 255, 0.2), transparent 30%),
          radial-gradient(circle at 92% 8%, rgba(141, 119, 255, 0.18), transparent 32%),
          radial-gradient(circle at 50% 98%, rgba(79, 116, 255, 0.16), transparent 36%),
          linear-gradient(156deg, var(--bg0), var(--bg1) 54%, var(--bg2));
        overflow: hidden;
      }

      body::before {
        content: "";
        position: fixed;
        inset: 0;
        pointer-events: none;
        background:
          linear-gradient(rgba(93, 126, 186, 0.06) 1px, transparent 1px),
          linear-gradient(90deg, rgba(93, 126, 186, 0.06) 1px, transparent 1px);
        background-size: 38px 38px;
        mask-image: radial-gradient(circle at center, black 18%, transparent 82%);
      }

      .phone-shell {
        width: min(430px, 100%);
        border-radius: 36px;
        border: 1px solid rgba(133, 175, 240, 0.3);
        padding: 8px;
        background:
          linear-gradient(170deg, rgba(16, 26, 47, 0.9), rgba(7, 12, 24, 0.98)),
          radial-gradient(circle at 12% 0%, rgba(65, 232, 255, 0.15), transparent 38%);
        box-shadow:
          0 30px 70px rgba(2, 5, 14, 0.76),
          0 0 0 1px rgba(122, 171, 246, 0.12);
      }

      .phone {
        height: min(860px, calc(100vh - 28px));
        min-height: 700px;
        border-radius: 28px;
        border: 1px solid rgba(128, 165, 219, 0.24);
        overflow: hidden;
        position: relative;
        background:
          radial-gradient(circle at 84% -10%, rgba(65, 232, 255, 0.24), transparent 34%),
          radial-gradient(circle at 8% 104%, rgba(141, 119, 255, 0.18), transparent 35%),
          linear-gradient(180deg, #0d1428, #091121 58%, #060d18);
      }

      .notch {
        position: absolute;
        top: 10px;
        left: 50%;
        transform: translateX(-50%);
        width: 116px;
        height: 24px;
        border-radius: 999px;
        background: rgba(31, 43, 60, 0.78);
        z-index: 8;
      }

      .app {
        height: 100%;
        display: grid;
        grid-template-rows: auto 1fr;
      }

      .status {
        padding: 42px 18px 10px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        color: var(--muted);
        font-size: 12px;
      }

      .status strong {
        font-family: "Orbitron", "Noto Sans SC", sans-serif;
        letter-spacing: 0.12em;
        color: #e5f3ff;
      }

      .screen-wrap {
        position: relative;
        overflow: hidden;
      }

      .screen {
        position: absolute;
        inset: 0;
        padding: 10px 14px 16px;
        overflow-y: auto;
        opacity: 0;
        pointer-events: none;
        transform: translateY(12px) scale(0.985);
        transition: opacity 0.3s ease, transform 0.3s ease;
      }

      .screen.active {
        opacity: 1;
        pointer-events: auto;
        transform: translateY(0) scale(1);
      }

      .hero {
        border-radius: 18px;
        border: 1px solid var(--line);
        padding: 14px;
        background:
          linear-gradient(180deg, rgba(20, 33, 59, 0.86), rgba(12, 21, 40, 0.9)),
          radial-gradient(circle at 90% 0%, rgba(65, 232, 255, 0.14), transparent 42%);
        position: relative;
        overflow: hidden;
      }

      .hero::after {
        content: "";
        position: absolute;
        left: 0;
        top: 0;
        right: 0;
        height: 4px;
        background: linear-gradient(90deg, var(--cyan), var(--blue), var(--violet), var(--mint));
      }

      .hero h1 {
        margin: 0;
        font-family: "Orbitron", "Noto Sans SC", sans-serif;
        font-size: 1.03rem;
        letter-spacing: 0.04em;
        font-weight: 600;
      }

      .hero p {
        margin: 8px 0 0;
        font-size: 12px;
        color: var(--muted);
      }

      .hero-top {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        gap: 8px;
      }

      .hero-actions {
        display: flex;
        gap: 6px;
      }

      .icon-btn {
        width: 30px;
        height: 30px;
        border-radius: 9px;
        border: 1px solid rgba(131, 168, 224, 0.36);
        background:
          linear-gradient(145deg, rgba(32, 47, 78, 0.88), rgba(19, 31, 54, 0.88)),
          radial-gradient(circle at 20% 10%, rgba(65, 232, 255, 0.16), transparent 46%);
        color: #d9ecff;
        font: inherit;
        font-weight: 700;
        display: grid;
        place-items: center;
        cursor: pointer;
        box-shadow: inset 0 0 14px rgba(65, 232, 255, 0.05);
      }

      .card {
        margin-top: 10px;
        border-radius: 16px;
        border: 1px solid rgba(126, 163, 219, 0.25);
        background:
          linear-gradient(180deg, rgba(19, 30, 52, 0.82), rgba(12, 20, 37, 0.9)),
          radial-gradient(circle at 94% 0%, rgba(79, 116, 255, 0.14), transparent 40%);
        padding: 10px;
        box-shadow:
          0 12px 28px rgba(6, 10, 20, 0.45),
          inset 0 0 0 1px rgba(159, 196, 255, 0.04);
      }

      .setup-screen {
        display: flex;
        flex-direction: column;
        gap: 10px;
        min-height: 100%;
      }

      .setup-avatar-wrap {
        margin-top: 4px;
      }

      .setup-question-card {
        min-height: 220px;
        margin-top: 0;
        padding: 14px;
      }

      .setup-stage {
        display: grid;
        gap: 2px;
        margin-bottom: 10px;
      }

      .setup-stage strong {
        font-family: "Orbitron", "Noto Sans SC", sans-serif;
        font-size: 12px;
        letter-spacing: 0.08em;
        color: #cce0ff;
      }

      .setup-stage small {
        font-size: 11px;
        color: var(--muted);
      }

      .question-text {
        margin: 0;
        min-height: 128px;
        display: grid;
        align-content: center;
        font-size: 1.04rem;
        line-height: 1.6;
      }

      .setup-progress {
        margin-top: 10px;
        display: grid;
        gap: 7px;
      }

      .setup-progress-head {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 8px;
      }

      .setup-progress span {
        font-family: "Orbitron", "Noto Sans SC", sans-serif;
        font-size: 12px;
        letter-spacing: 0.08em;
        color: #b6cdf5;
      }

      .record-badge {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 2px 8px;
        border-radius: 999px;
        border: 1px solid rgba(119, 158, 219, 0.34);
        background: rgba(16, 27, 48, 0.75);
        color: #acc6ea;
        font-size: 10px;
      }

      .record-dot {
        width: 7px;
        height: 7px;
        border-radius: 50%;
        background: #6f8cb8;
      }

      .record-dot.live {
        background: #ff5b78;
        box-shadow: 0 0 10px rgba(255, 91, 120, 0.45);
        animation: recordPulse 1.1s ease-in-out infinite;
      }

      .avatar-picker {
        margin-top: 10px;
        border-top: 1px solid rgba(126, 166, 224, 0.2);
        padding-top: 10px;
      }

      .avatar-options {
        display: grid;
        grid-template-columns: repeat(3, minmax(0, 1fr));
        gap: 8px;
      }

      .avatar-option {
        border: 1px solid rgba(123, 157, 214, 0.3);
        border-radius: 12px;
        background: rgba(15, 25, 45, 0.76);
        padding: 8px;
        display: grid;
        justify-items: center;
        gap: 6px;
        cursor: pointer;
      }

      .avatar-option.active {
        border-color: rgba(94, 255, 189, 0.55);
        box-shadow: 0 0 0 1px rgba(94, 255, 189, 0.25);
      }

      .avatar-chip {
        width: 34px;
        height: 34px;
        border-radius: 11px;
        background: linear-gradient(145deg, var(--avatar-a, #87a8d6), var(--avatar-b, #6a84b0));
        box-shadow: 0 4px 10px rgba(6, 11, 22, 0.42);
      }

      .avatar-option p {
        margin: 0;
        font-size: 10px;
        color: #bdd1f0;
      }

      .avatar-ai-tools {
        margin-top: 10px;
        display: grid;
        grid-template-columns: 1fr auto;
        gap: 8px;
      }

      .mini-input {
        border-radius: 10px;
        border: 1px solid rgba(126, 160, 217, 0.32);
        background: rgba(13, 22, 39, 0.82);
        color: var(--text);
        font: inherit;
        font-size: 12px;
        padding: 9px;
      }

      .tiny-btn {
        border: 0;
        border-radius: 10px;
        padding: 9px 12px;
        font: inherit;
        font-size: 12px;
        color: #eef7ff;
        background: linear-gradient(120deg, var(--blue), var(--violet));
        cursor: pointer;
      }

      .hidden {
        display: none !important;
      }

      .track {
        margin-top: 0;
        height: 4px;
        border-radius: 999px;
        background: rgba(125, 151, 199, 0.2);
        overflow: hidden;
      }

      .fill {
        height: 100%;
        width: 0;
        border-radius: inherit;
        background: linear-gradient(90deg, var(--cyan), var(--blue));
        transition: width 0.35s ease;
      }

      .setup-nav {
        position: sticky;
        bottom: 0;
        margin-top: auto;
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 8px;
        padding: 10px 0 2px;
        background: linear-gradient(180deg, transparent, rgba(8, 14, 27, 0.86) 42%);
      }

      .avatar-wrap {
        margin-top: 10px;
        display: grid;
        justify-items: center;
        gap: 7px;
      }

      .avatar-stage {
        width: 160px;
        height: 160px;
        position: relative;
        display: grid;
        place-items: center;
        background: radial-gradient(circle at 50% 45%, rgba(38, 54, 89, 0.72) 0, rgba(23, 34, 58, 0.62) 70%, transparent 72%);
        border-radius: 50%;
      }

      .avatar-ring {
        position: absolute;
        border-radius: 50%;
        border: 2px solid rgba(96, 136, 204, 0.36);
        animation: spin 14s linear infinite;
      }

      .avatar-ring.r1 {
        width: 148px;
        height: 148px;
      }

      .avatar-ring.r2 {
        width: 118px;
        height: 118px;
        border-style: dotted;
        border-color: rgba(141, 119, 255, 0.42);
        animation: spinBack 12s linear infinite;
      }

      .avatar-accent {
        position: absolute;
        top: 18px;
        width: 118px;
        height: 56px;
        border-radius: 999px;
        background: linear-gradient(180deg, rgba(65, 232, 255, 0.2), transparent);
      }

      .avatar-body {
        position: absolute;
        bottom: 20px;
        width: 86px;
        height: 56px;
        border-radius: 26px 26px 18px 18px;
        background: linear-gradient(180deg, #3d5f91, #2a3f63);
        box-shadow: inset 0 -8px 12px rgba(9, 15, 29, 0.55);
      }

      .avatar-core {
        width: 74px;
        height: 74px;
        border-radius: 50%;
        background: radial-gradient(circle at 32% 30%, rgba(255, 238, 224, 0.96), rgba(241, 196, 162, 0.94));
        box-shadow:
          0 5px 12px rgba(11, 20, 38, 0.38),
          inset 0 -6px 10px rgba(189, 130, 97, 0.25);
        display: grid;
        place-items: center;
        animation: avatarFloat 3.1s ease-in-out infinite;
        overflow: hidden;
      }

      .avatar-core::before {
        content: "";
        position: absolute;
        top: -12px;
        left: 8px;
        width: 58px;
        height: 34px;
        border-radius: 20px 20px 16px 16px;
        background: #835e4d;
      }

      .avatar-core::after {
        content: "";
        position: absolute;
        top: 7px;
        left: -6px;
        width: 20px;
        height: 22px;
        border-radius: 50%;
        background: #8e6654;
      }

      .avatar-face {
        position: relative;
        z-index: 1;
        width: 56px;
        height: 42px;
        display: grid;
        grid-template-areas:
          "left right"
          "mouth mouth";
        align-items: center;
        justify-items: center;
      }

      .eye {
        width: 9px;
        height: 9px;
        border-radius: 50%;
        background: #443427;
        animation: blink 5.1s infinite;
      }

      .eye.left {
        grid-area: left;
      }

      .eye.right {
        grid-area: right;
      }

      .mouth {
        grid-area: mouth;
        width: 20px;
        height: 5px;
        border-radius: 999px;
        background: #8a5343;
        margin-top: 6px;
      }

      .avatar-stage.idle .avatar-ring {
        opacity: 0.78;
      }

      .avatar-stage.listening .avatar-ring.r1 {
        border-color: rgba(65, 232, 255, 0.66);
        box-shadow: 0 0 14px rgba(65, 232, 255, 0.24);
      }

      .avatar-stage.listening .avatar-core {
        animation: avatarPulse 1.25s ease-in-out infinite;
      }

      .avatar-stage.thinking .avatar-ring.r2 {
        animation-duration: 3.2s;
      }

      .avatar-stage.speaking .mouth {
        animation: mouthTalk 0.28s ease-in-out infinite alternate;
      }

      .avatar-stage.avatar-self .avatar-body {
        background: linear-gradient(180deg, #8a72ab, #65527e);
        box-shadow: inset 0 -8px 12px rgba(60, 43, 83, 0.34);
      }

      .avatar-stage.avatar-self .avatar-core::before,
      .avatar-stage.avatar-self .avatar-core::after {
        background: #2f4058;
      }

      .avatar-stage.avatar-self .avatar-ring.r1 {
        border-color: rgba(136, 97, 154, 0.5);
      }

      .avatar-stage.avatar-self.listening .avatar-ring.r1 {
        border-color: rgba(136, 97, 154, 0.72);
        box-shadow: 0 0 14px rgba(136, 97, 154, 0.2);
      }

      .avatar-meta {
        margin: 0;
        font-size: 11px;
        color: #a9bddf;
      }

      .model-wrap {
        margin-top: 12px;
        border-radius: 22px;
        border: 1px solid rgba(133, 167, 223, 0.36);
        min-height: 520px;
        padding: 16px;
        background:
          radial-gradient(circle at center, rgba(65, 232, 255, 0.17), rgba(13, 21, 37, 0.88)),
          linear-gradient(180deg, rgba(18, 29, 52, 0.94), rgba(10, 17, 31, 0.96));
        box-shadow: 0 18px 40px rgba(3, 8, 20, 0.5);
      }

      .orb-zone {
        height: 250px;
        display: grid;
        place-items: center;
        position: relative;
      }

      .ring,
      .ring::before,
      .ring::after {
        content: "";
        position: absolute;
        border-radius: 50%;
      }

      .ring {
        width: 172px;
        height: 172px;
        border: 2px solid rgba(65, 232, 255, 0.55);
        animation: spin 8s linear infinite;
      }

      .ring::before {
        inset: 16px;
        border: 2px dashed rgba(138, 117, 255, 0.58);
        animation: spinBack 6s linear infinite;
      }

      .ring::after {
        inset: 40px;
        border: 2px solid rgba(94, 255, 189, 0.56);
        animation: spin 4.9s linear infinite;
      }

      .core {
        width: 56px;
        height: 56px;
        border-radius: 50%;
        background: radial-gradient(circle, #f4fbff 0%, #9be6ff 44%, #5aa8ff 100%);
        box-shadow:
          0 0 20px rgba(65, 232, 255, 0.5),
          0 0 34px rgba(138, 117, 255, 0.3);
        animation: corePulse 1.6s ease-in-out infinite;
      }

      .model-title {
        text-align: center;
        font-family: "Orbitron", "Noto Sans SC", sans-serif;
        font-size: 1rem;
        letter-spacing: 0.04em;
      }

      .model-sub {
        margin-top: 6px;
        text-align: center;
        color: #9ab3d8;
        font-size: 12px;
      }

      .model-label {
        margin-top: 12px;
        display: flex;
        justify-content: space-between;
        font-size: 12px;
      }

      .model-log {
        margin: 10px 0 0;
        padding: 0;
        display: grid;
        gap: 6px;
      }

      .model-log li {
        list-style: none;
        font-size: 12px;
        color: #b8cdf0;
        border-radius: 10px;
        border: 1px solid rgba(136, 172, 229, 0.28);
        background: rgba(21, 33, 58, 0.84);
        padding: 8px;
      }

      .model-log li.done {
        border-color: rgba(94, 255, 189, 0.42);
        color: #97ffd3;
      }

      .contacts-head {
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-size: 12px;
        color: var(--muted);
      }

      .tag {
        border-radius: 999px;
        border: 1px solid rgba(132, 168, 223, 0.38);
        background: rgba(20, 33, 58, 0.84);
        padding: 4px 8px;
      }

      .contact-item {
        margin-top: 8px;
        border: 1px solid rgba(128, 163, 216, 0.25);
        border-radius: 14px;
        background:
          linear-gradient(180deg, rgba(21, 33, 57, 0.82), rgba(13, 22, 39, 0.88)),
          radial-gradient(circle at 100% 0%, rgba(79, 116, 255, 0.12), transparent 42%);
        padding: 9px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 8px;
      }

      .contact-left {
        display: flex;
        align-items: center;
        gap: 8px;
        min-width: 0;
      }

      .contact-avatar {
        width: 34px;
        height: 34px;
        border-radius: 12px;
        flex: 0 0 auto;
        background: linear-gradient(150deg, var(--contact-a, #9dcbd9), var(--contact-b, #7d95bc));
        box-shadow: 0 4px 10px rgba(8, 14, 27, 0.42);
      }

      .contact-name {
        margin: 0;
        font-size: 13px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .contact-sub {
        margin: 2px 0 0;
        font-size: 11px;
        color: var(--muted);
      }

      .mini-call {
        border: 0;
        border-radius: 10px;
        padding: 8px 9px;
        font-size: 12px;
        color: #ffffff;
        background: linear-gradient(120deg, var(--cyan), var(--blue) 58%, var(--violet));
        cursor: pointer;
      }

      .call-timer {
        margin: 8px 0 0;
        text-align: center;
        font-family: "Orbitron", "Noto Sans SC", sans-serif;
        font-size: 1.1rem;
        letter-spacing: 0.02em;
      }

      .call-state {
        margin: 4px 0 0;
        text-align: center;
        color: var(--muted);
        font-size: 12px;
      }

      .voice-panel {
        margin-top: 10px;
        border-radius: 14px;
        border: 1px solid rgba(125, 151, 196, 0.28);
        background: rgba(18, 28, 49, 0.84);
        padding: 10px;
        box-shadow: 0 8px 20px rgba(7, 12, 22, 0.32);
      }

      .live-caption {
        margin: 0;
        font-size: 12px;
        color: #a8bcde;
        min-height: 34px;
      }

      .wave {
        margin-top: 8px;
        height: 42px;
        border-radius: 10px;
        border: 1px solid rgba(122, 147, 191, 0.3);
        display: grid;
        grid-template-columns: repeat(24, minmax(0, 1fr));
        gap: 3px;
        align-items: end;
        padding: 6px;
        background:
          linear-gradient(180deg, rgba(20, 32, 54, 0.82), rgba(15, 24, 43, 0.92)),
          repeating-linear-gradient(90deg, rgba(124, 155, 205, 0.12) 0 1px, transparent 1px 7px);
      }

      .wave i {
        height: 16%;
        border-radius: 999px;
        background: linear-gradient(180deg, #5fd6ff, #6b84ff);
        transition: height 0.2s ease;
      }

      .danger-btn {
        margin-top: 8px;
        width: 100%;
        border: 1px solid rgba(204, 96, 120, 0.56);
        border-radius: 12px;
        padding: 10px;
        font: inherit;
        color: #f8d6db;
        background: rgba(99, 31, 44, 0.5);
        cursor: pointer;
      }

      .form-head {
        margin: 0 0 8px;
        font-size: 13px;
      }

      .form-label {
        display: block;
        margin-top: 8px;
        font-size: 12px;
        color: var(--muted);
      }

      .text-input {
        width: 100%;
        margin-top: 6px;
        border: 1px solid rgba(130, 163, 219, 0.34);
        border-radius: 11px;
        background: rgba(12, 21, 40, 0.82);
        color: var(--text);
        padding: 10px;
        font: inherit;
      }

      .primary-btn,
      .secondary-btn {
        width: 100%;
        margin-top: 8px;
        border-radius: 11px;
        padding: 11px;
        font: inherit;
        font-weight: 600;
        cursor: pointer;
      }

      .primary-btn {
        border: 0;
        color: #f4f8ff;
        background: linear-gradient(120deg, var(--cyan), var(--blue) 58%, var(--violet));
        box-shadow: 0 8px 18px rgba(58, 96, 200, 0.32);
      }

      .secondary-btn {
        border: 1px solid rgba(125, 158, 211, 0.34);
        color: #d3e5ff;
        background: rgba(19, 31, 55, 0.78);
      }

      .secondary-btn:disabled {
        opacity: 0.45;
        cursor: not-allowed;
      }

      .form-note {
        margin: 8px 0 0;
        font-size: 12px;
        color: #a3b7d8;
      }

      .audio-preview {
        width: 100%;
        margin-top: 8px;
      }

      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }

      @keyframes spinBack {
        to {
          transform: rotate(-360deg);
        }
      }

      @keyframes corePulse {
        0%,
        100% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.16);
        }
      }

      @keyframes avatarFloat {
        0%,
        100% {
          transform: translateY(0);
        }
        50% {
          transform: translateY(-4px);
        }
      }

      @keyframes avatarPulse {
        0%,
        100% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.08);
        }
      }

      @keyframes mouthTalk {
        0% {
          width: 18px;
          height: 4px;
          border-radius: 999px;
        }
        100% {
          width: 12px;
          height: 12px;
          border-radius: 50%;
        }
      }

      @keyframes blink {
        0%,
        45%,
        55%,
        100% {
          transform: scaleY(1);
        }
        50% {
          transform: scaleY(0.1);
        }
      }

      @keyframes recordPulse {
        0%,
        100% {
          transform: scale(1);
          opacity: 1;
        }
        50% {
          transform: scale(1.28);
          opacity: 0.72;
        }
      }

      @media (max-width: 420px) {
        .phone-shell {
          border-radius: 30px;
          padding: 6px;
        }

        .phone {
          border-radius: 24px;
          min-height: 680px;
        }
      }
    </style>
  </head>
  <body>
    <div class="phone-shell">
      <div class="phone">
        <div class="notch"></div>
        <div class="app">
          <header class="status">
            <strong>VOICE TWIN</strong>
            <span id="status-text">准备开始创建</span>
          </header>

          <div class="screen-wrap">
            <section class="screen setup-screen" id="setup-screen">
              <section class="avatar-wrap setup-avatar-wrap">
                <div class="avatar-stage avatar-mentor listening" id="setup-avatar">
                  <i class="avatar-ring r1"></i>
                  <i class="avatar-ring r2"></i>
                  <i class="avatar-accent"></i>
                  <div class="avatar-body"></div>
                  <div class="avatar-core">
                    <div class="avatar-face">
                      <i class="eye left"></i>
                      <i class="eye right"></i>
                      <i class="mouth"></i>
                    </div>
                  </div>
                </div>
              </section>

              <section class="card setup-question-card">
                <div class="setup-stage">
                  <strong id="setup-stage-pillar">TELOS · MISSION</strong>
                  <small id="setup-stage-ritual">仪式阶段 · 北极星点火</small>
                </div>
                <p class="question-text" id="setup-question">你最希望这个数字人长期帮你完成什么？</p>
                <section class="avatar-picker hidden" id="avatar-picker">
                  <div class="avatar-options" id="avatar-options"></div>
                  <div class="avatar-ai-tools">
                    <input
                      class="mini-input"
                      id="avatar-ai-prompt"
                      type="text"
                      placeholder="输入关键词（理性 / 温暖 / 锋利...）"
                    />
                    <button class="tiny-btn" id="avatar-ai-generate-btn">AI 生成</button>
                  </div>
                  <p class="form-note" id="avatar-ai-note">你也可以直接点选头像。</p>
                </section>
                <div class="setup-progress">
                  <div class="setup-progress-head">
                    <span id="setup-progress-text">1 / 8</span>
                    <span class="record-badge" id="setup-recording-badge">
                      <i class="record-dot" id="setup-record-dot"></i>
                      <span id="setup-record-text">等待录音</span>
                    </span>
                  </div>
                  <div class="track"><div class="fill" id="setup-progress-fill" style="width: 25%"></div></div>
                </div>
              </section>

              <section class="setup-nav">
                <button class="secondary-btn" id="setup-prev-btn">上一题</button>
                <button class="primary-btn" id="setup-next-btn">下一题</button>
              </section>
            </section>

            <section class="screen" id="model-screen">
              <article class="hero">
                <h1>建模仪式</h1>
                <p>正在融合人格与语音特征。</p>
              </article>

              <article class="model-wrap">
                <div class="orb-zone">
                  <div class="ring"></div>
                  <div class="core"></div>
                </div>
                <div class="model-title" id="model-title">初始化建模引擎</div>
                <div class="model-sub" id="model-sub">检查采集结构...</div>
                <div class="model-label"><strong>进度</strong><span id="model-percent">0%</span></div>
                <div class="track"><div class="fill" id="model-fill" style="width: 0%"></div></div>
                <ul class="model-log" id="model-log"></ul>
              </article>
            </section>

            <section class="screen" id="home-screen">
              <article class="hero">
                <div class="hero-top">
                  <div>
                    <h1>数字人通讯录</h1>
                    <p>随时发起语音电话。</p>
                  </div>
                  <div class="hero-actions">
                    <button class="icon-btn" id="add-entry-btn" title="添加数字人">+</button>
                    <button class="icon-btn" id="settings-entry-btn" title="设置">⚙</button>
                  </div>
                </div>
              </article>

              <section class="card">
                <div class="contacts-head">
                  <span>置顶联系人</span>
                  <span class="tag">YOU</span>
                </div>
                <div class="contact-item">
                  <div class="contact-left">
                    <div class="contact-avatar" id="self-contact-avatar"></div>
                    <div>
                      <p class="contact-name" id="self-contact-name">我的数字人（你）</p>
                      <p class="contact-sub" id="self-contact-sub">人格与语音建模已完成</p>
                    </div>
                  </div>
                  <button class="mini-call" data-contact-id="self">语音电话</button>
                </div>
              </section>

              <section class="card">
                <div class="contacts-head">
                  <span>其他数字人</span>
                  <span class="tag" id="contacts-count-tag">0</span>
                </div>
                <div id="contact-list"></div>
              </section>
            </section>

            <section class="screen" id="call-screen">
              <article class="hero">
                <h1 id="call-title">与数字人通话中</h1>
                <p id="call-sub">语音实时接通</p>
              </article>

              <section class="avatar-wrap">
                <div class="avatar-stage avatar-self listening" id="call-avatar">
                  <i class="avatar-ring r1"></i>
                  <i class="avatar-ring r2"></i>
                  <i class="avatar-accent"></i>
                  <div class="avatar-body"></div>
                  <div class="avatar-core">
                    <div class="avatar-face">
                      <i class="eye left"></i>
                      <i class="eye right"></i>
                      <i class="mouth"></i>
                    </div>
                  </div>
                </div>
                <p class="avatar-meta" id="call-avatar-meta">正在聆听</p>
              </section>

              <p class="call-timer" id="call-timer">00:00</p>
              <p class="call-state" id="call-state">语音通话已接通</p>

              <section class="voice-panel">
                <p class="live-caption" id="call-caption">实时转写: 通话已接通...</p>
                <div class="wave" id="call-wave"></div>
                <button class="danger-btn" id="hangup-btn">挂断电话</button>
              </section>
            </section>

            <section class="screen" id="add-screen">
              <article class="hero">
                <h1>添加数字人</h1>
                <p>通过数字 ID 添加到通讯录。</p>
              </article>

              <section class="card">
                <label class="form-label" for="add-id-input">数字 ID</label>
                <input class="text-input" id="add-id-input" type="text" placeholder="例如: twin_2048" />
                <button class="primary-btn" id="add-id-confirm-btn">添加到通讯录</button>
                <p class="form-note" id="add-id-feedback">请输入数字 ID。</p>
                <button class="secondary-btn" id="add-id-back-btn">返回通讯录</button>
              </section>
            </section>

            <section class="screen" id="settings-screen">
              <article class="hero">
                <h1>我的数字人设置</h1>
                <p>查询、更新和分享你的数字人。</p>
              </article>

              <section class="card">
                <div class="form-head"><strong>查询</strong></div>
                <button class="primary-btn" id="query-profile-btn">查询当前信息</button>
                <p class="form-note" id="query-profile-result">尚未查询。</p>
              </section>

              <section class="card">
                <div class="form-head"><strong>更新</strong></div>
                <label class="form-label" for="update-name-input">显示名称</label>
                <input class="text-input" id="update-name-input" type="text" placeholder="我的数字人（你）" />
                <label class="form-label" for="update-style-select">语音风格</label>
                <select class="text-input" id="update-style-select">
                  <option value="balanced">平衡</option>
                  <option value="calm">沉稳</option>
                  <option value="direct">干练</option>
                </select>
                <button class="primary-btn" id="save-profile-btn">保存更新</button>
                <p class="form-note" id="save-profile-result">尚未更新。</p>
              </section>

              <section class="card">
                <div class="form-head"><strong>分享</strong></div>
                <input class="text-input" id="share-code-output" type="text" value="VT-SHARE-0000" readonly />
                <button class="primary-btn" id="gen-share-code-btn">生成分享码</button>
                <button class="secondary-btn" id="copy-share-code-btn">复制分享码</button>
                <p class="form-note" id="share-result">可生成后分享。</p>
                <button class="secondary-btn" id="settings-back-btn">返回通讯录</button>
              </section>

              <section class="card">
                <div class="form-head"><strong>MiniMax 声音复刻</strong></div>
                <label class="form-label" for="minimax-api-key-input">MiniMax API Key</label>
                <input
                  class="text-input"
                  id="minimax-api-key-input"
                  type="password"
                  placeholder="输入你的 MiniMax API Key"
                />
                <p class="form-note" id="minimax-voice-id">voice_id: 未生成</p>
                <button class="primary-btn" id="minimax-clone-btn">使用当前采集音频复刻声音</button>
                <p class="form-note" id="minimax-clone-status">未执行</p>
                <audio class="audio-preview hidden" id="minimax-demo-audio" controls preload="none"></audio>
              </section>
            </section>
          </div>
        </div>
      </div>
    </div>

    <script>
      const STORAGE_KEY = "voiceTwinState.v2";
      const MINIMAX_BASE_URL = "https://api.minimax.io/v1";
      const MINIMAX_TTS_MODEL = "speech-2.5-hd";
      const MINIMAX_ASSISTANT_VOICE_ID = "male-qn-qingse";
      const MINIMAX_DIGITAL_FALLBACK_VOICE_ID = "male-qn-qingse";
      const MINIMAX_CHAT_MODEL = "M2-her";

      const setupFlow = [
        {
          id: "mission",
          type: "question",
          pillar: "MISSION",
          ritual: "北极星点火",
          question: "十年后回看今天，你最希望这个数字人持续帮你守住什么？"
        },
        {
          id: "goals",
          type: "question",
          pillar: "GOALS",
          ritual: "目标锚定",
          question: "接下来 90 天，你最关键的三个目标分别是什么？"
        },
        {
          id: "beliefs",
          type: "question",
          pillar: "BELIEFS",
          ritual: "价值校准",
          question: "当效率、关系、长期价值冲突时，你通常优先守哪一条原则？"
        },
        {
          id: "models",
          type: "question",
          pillar: "MODELS",
          ritual: "认知映射",
          question: "你做重要决策时，最依赖的判断框架或思考模型是什么？"
        },
        {
          id: "strategies",
          type: "question",
          pillar: "STRATEGIES",
          ritual: "策略注入",
          question: "面对复杂任务，你会如何拆解优先级并推进执行？"
        },
        {
          id: "narratives",
          type: "question",
          pillar: "NARRATIVES",
          ritual: "叙事封存",
          question: "请讲一个你从挫折走出来并重建节奏的真实经历。"
        },
        {
          id: "challenges_ideas",
          type: "question",
          pillar: "CHALLENGES / IDEAS",
          ritual: "边界激活",
          question: "你当前最大的挑战是什么？如果不受限制，你最想尝试的新想法是什么？"
        },
        {
          id: "avatar",
          type: "avatar",
          pillar: "AVATAR",
          ritual: "化身定影",
          question: "最后一步：选择你的虚拟形象"
        }
      ];

      const questionStepIds = setupFlow.filter((item) => item.type === "question").map((item) => item.id);

      const avatarCatalog = [
        { id: "aurora", name: "极光策士", group: "analysts", a: "#88619a", b: "#b095bd" },
        { id: "pulse", name: "脉冲指挥官", group: "sentinels", a: "#4298b4", b: "#82c2d5" },
        { id: "ember", name: "流焰创想者", group: "explorers", a: "#e4ae3a", b: "#f0d287" },
        { id: "lumen", name: "光域共情者", group: "diplomats", a: "#33a474", b: "#73c3a0" },
        { id: "nova", name: "星核执行体", group: "analysts", a: "#6778ff", b: "#7de4ff" },
        { id: "orbit", name: "轨道协同者", group: "sentinels", a: "#5f78af", b: "#8ea4d6" }
      ];

      const styleLabels = {
        balanced: "平衡",
        calm: "沉稳",
        direct: "干练"
      };

      const groupPalette = {
        analysts: { a: "#88619a", b: "#b095bd" },
        diplomats: { a: "#33a474", b: "#73c3a0" },
        sentinels: { a: "#4298b4", b: "#82c2d5" },
        explorers: { a: "#e4ae3a", b: "#f0d287" }
      };

      const avatarMap = Object.fromEntries(avatarCatalog.map((item) => [item.id, item]));

      function deepCopy(value) {
        return JSON.parse(JSON.stringify(value));
      }

      function createDefaultState() {
        return {
          onboardingDone: false,
          setup: {
            index: 0,
            answers: Object.fromEntries(questionStepIds.map((id) => [id, ""])),
            recordingDurationSec: 0
          },
          model: {
            builtAt: "",
            personaSummary: "",
            voiceSummary: "",
            voiceClone: {
              status: "idle",
              voiceId: "",
              demoAudio: "",
              error: "",
              recordedDurationSec: 0,
              updatedAt: ""
            }
          },
          integration: {
            minimaxApiKey: ""
          },
          chat: {
            historyByContact: {}
          },
          selfProfile: {
            id: "self",
            digitalId: "twin_self_001",
            name: "我的数字人（你）",
            style: "balanced",
            shareCode: "VT-SHARE-0000",
            group: "analysts",
            avatarId: "aurora"
          },
          contacts: [
            { id: "planner", name: "执行规划师", sub: "目标拆解与优先级建议", group: "sentinels" },
            { id: "coach", name: "复盘教练", sub: "每日回顾与改进建议", group: "diplomats" },
            { id: "creator", name: "内容共创体", sub: "口播与表达优化建议", group: "explorers" }
          ]
        };
      }

      function normalizeState(saved) {
        const base = createDefaultState();
        if (!saved || typeof saved !== "object") return base;

        const result = deepCopy(base);
        result.onboardingDone = Boolean(saved.onboardingDone);

        if (saved.setup && typeof saved.setup === "object") {
          result.setup.index = Number.isInteger(saved.setup.index) ? saved.setup.index : 0;
          result.setup.recordingDurationSec = Number(saved.setup.recordingDurationSec || 0);

          const answers = saved.setup.answers;
          if (Array.isArray(answers)) {
            questionStepIds.forEach((id, idx) => {
              result.setup.answers[id] = String(answers[idx] || "");
            });
          } else if (answers && typeof answers === "object") {
            questionStepIds.forEach((id) => {
              result.setup.answers[id] = String(answers[id] || "");
            });
          }
        }

        if (saved.model && typeof saved.model === "object") {
          result.model.builtAt = String(saved.model.builtAt || "");
          result.model.personaSummary = String(saved.model.personaSummary || "");
          result.model.voiceSummary = String(saved.model.voiceSummary || "");

          if (saved.model.voiceClone && typeof saved.model.voiceClone === "object") {
            result.model.voiceClone.status = String(saved.model.voiceClone.status || "idle");
            result.model.voiceClone.voiceId = String(saved.model.voiceClone.voiceId || "");
            result.model.voiceClone.demoAudio = String(saved.model.voiceClone.demoAudio || "");
            result.model.voiceClone.error = String(saved.model.voiceClone.error || "");
            result.model.voiceClone.recordedDurationSec = Number(
              saved.model.voiceClone.recordedDurationSec || 0
            );
            result.model.voiceClone.updatedAt = String(saved.model.voiceClone.updatedAt || "");
          }
        }

        if (saved.integration && typeof saved.integration === "object") {
          result.integration.minimaxApiKey = String(saved.integration.minimaxApiKey || "");
        }

        if (saved.chat && typeof saved.chat === "object") {
          const rawHistory = saved.chat.historyByContact;
          if (rawHistory && typeof rawHistory === "object") {
            Object.entries(rawHistory).forEach(([contactId, turns]) => {
              if (!Array.isArray(turns)) return;
              const safeTurns = turns
                .filter((item) => item && typeof item === "object")
                .map((item) => ({
                  role: item.role === "assistant" ? "assistant" : "user",
                  content: String(item.content || "").slice(0, 800)
                }))
                .filter((item) => item.content)
                .slice(-16);
              result.chat.historyByContact[String(contactId)] = safeTurns;
            });
          }
        }

        if (saved.selfProfile && typeof saved.selfProfile === "object") {
          result.selfProfile.name = String(saved.selfProfile.name || result.selfProfile.name);
          result.selfProfile.digitalId = String(saved.selfProfile.digitalId || result.selfProfile.digitalId);
          result.selfProfile.style = String(saved.selfProfile.style || result.selfProfile.style);
          result.selfProfile.shareCode = String(saved.selfProfile.shareCode || result.selfProfile.shareCode);
          result.selfProfile.group = String(saved.selfProfile.group || result.selfProfile.group);
          result.selfProfile.avatarId = String(saved.selfProfile.avatarId || result.selfProfile.avatarId);
        }

        if (Array.isArray(saved.contacts)) {
          result.contacts = saved.contacts
            .filter((item) => item && typeof item === "object" && item.id && item.name)
            .map((item) => ({
              id: String(item.id),
              name: String(item.name),
              sub: String(item.sub || "语音数字人"),
              group: String(item.group || "sentinels")
            }))
            .filter((item) => item.id !== "self");
        }

        if (avatarMap[result.selfProfile.avatarId]) {
          result.selfProfile.group = avatarMap[result.selfProfile.avatarId].group;
        }

        result.setup.index = Math.min(setupFlow.length - 1, Math.max(0, result.setup.index));
        return result;
      }

      function loadState() {
        try {
          const raw = localStorage.getItem(STORAGE_KEY);
          if (!raw) return createDefaultState();
          return normalizeState(JSON.parse(raw));
        } catch {
          return createDefaultState();
        }
      }

      let state = loadState();

      function saveState() {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
      }

      function sleep(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
      }

      function formatDuration(totalSec) {
        const sec = Math.max(0, Math.floor(totalSec || 0));
        const m = String(Math.floor(sec / 60)).padStart(2, "0");
        const s = String(sec % 60).padStart(2, "0");
        return `${m}:${s}`;
      }

      const statusText = document.getElementById("status-text");
      const screens = {
        setup: document.getElementById("setup-screen"),
        model: document.getElementById("model-screen"),
        home: document.getElementById("home-screen"),
        call: document.getElementById("call-screen"),
        add: document.getElementById("add-screen"),
        settings: document.getElementById("settings-screen")
      };
      let currentScreen = "setup";

      function showScreen(name) {
        Object.values(screens).forEach((screen) => screen.classList.remove("active"));
        screens[name].classList.add("active");
        currentScreen = name;
        stopActiveTts();

        if (name !== "setup") {
          stopSetupListening();
        }
        if (name !== "call") {
          stopCallSession();
        }
      }

      function buildWave(container, count) {
        container.innerHTML = "";
        for (let i = 0; i < count; i += 1) {
          const bar = document.createElement("i");
          container.appendChild(bar);
        }
        return Array.from(container.querySelectorAll("i"));
      }

      function setWaveIdle(bars) {
        bars.forEach((bar, idx) => {
          bar.style.height = `${14 + (idx % 4) * 5}%`;
        });
      }

      let micAnalyser = null;
      let micData = null;
      let micReady = false;
      let micInitPromise = null;

      function ensureMic() {
        if (micReady) return Promise.resolve(true);
        if (micInitPromise) return micInitPromise;
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
          return Promise.resolve(false);
        }

        micInitPromise = navigator.mediaDevices
          .getUserMedia({ audio: true })
          .then((stream) => {
            const AudioContextClass = window.AudioContext || window.webkitAudioContext;
            if (!AudioContextClass) return false;
            const ctx = new AudioContextClass();
            const source = ctx.createMediaStreamSource(stream);
            const analyser = ctx.createAnalyser();
            analyser.fftSize = 128;
            analyser.smoothingTimeConstant = 0.7;
            source.connect(analyser);
            micAnalyser = analyser;
            micData = new Uint8Array(analyser.frequencyBinCount);
            micReady = true;
            return true;
          })
          .catch(() => false)
          .then((ok) => {
            if (!ok) micInitPromise = null;
            return ok;
          });

        return micInitPromise;
      }

      function animateWave(bars) {
        if (micReady && micAnalyser && micData) {
          micAnalyser.getByteFrequencyData(micData);
          const step = Math.max(1, Math.floor(micData.length / bars.length));
          bars.forEach((bar, idx) => {
            const raw = micData[Math.min(micData.length - 1, idx * step)] / 255;
            const smooth = Math.min(1, Math.max(0.06, raw * 1.25));
            bar.style.height = `${12 + smooth * 86}%`;
          });
          return;
        }

        bars.forEach((bar) => {
          bar.style.height = `${Math.max(12, Math.floor(Math.random() * 86))}%`;
        });
      }

      function setAvatarState(avatarEl, labelEl, mode, labelText) {
        avatarEl.classList.remove("idle", "listening", "speaking", "thinking");
        avatarEl.classList.add(mode);
        if (labelText && labelEl) labelEl.textContent = labelText;
      }

      function pickChineseVoice() {
        if (!window.speechSynthesis) return null;
        const voices = window.speechSynthesis.getVoices();
        if (!voices || !voices.length) return null;
        return (
          voices.find((voice) => voice.lang && voice.lang.toLowerCase().startsWith("zh")) ||
          voices.find((voice) => voice.lang && voice.lang.toLowerCase().startsWith("en")) ||
          null
        );
      }

      let speechReady = false;
      if (window.speechSynthesis) {
        window.speechSynthesis.onvoiceschanged = () => {
          speechReady = true;
        };
        speechReady = true;
      }

      const minimaxAudioPlayer = new Audio();
      let minimaxAudioUrl = "";
      let activeSpeakToken = 0;

      function revokeMiniMaxAudioUrl() {
        if (!minimaxAudioUrl) return;
        URL.revokeObjectURL(minimaxAudioUrl);
        minimaxAudioUrl = "";
      }

      function haltSpeechPlayback() {
        if (window.speechSynthesis) {
          window.speechSynthesis.cancel();
        }
        minimaxAudioPlayer.pause();
        minimaxAudioPlayer.removeAttribute("src");
        revokeMiniMaxAudioUrl();
      }

      function stopActiveTts() {
        activeSpeakToken += 1;
        haltSpeechPlayback();
      }

      function isHexAudio(text) {
        return typeof text === "string" && text.length > 16 && text.length % 2 === 0 && /^[0-9a-fA-F]+$/.test(text);
      }

      function hexToBytes(hex) {
        const bytes = new Uint8Array(hex.length / 2);
        for (let i = 0; i < hex.length; i += 2) {
          bytes[i / 2] = parseInt(hex.slice(i, i + 2), 16);
        }
        return bytes;
      }

      function base64ToBytes(base64) {
        const raw = atob(base64);
        const bytes = new Uint8Array(raw.length);
        for (let i = 0; i < raw.length; i += 1) {
          bytes[i] = raw.charCodeAt(i);
        }
        return bytes;
      }

      function getSpeakerVoiceId(speaker) {
        if (speaker === "assistant") {
          return MINIMAX_ASSISTANT_VOICE_ID;
        }
        if (speaker === "digital" && state.model.voiceClone.voiceId) {
          return state.model.voiceClone.voiceId;
        }
        return MINIMAX_DIGITAL_FALLBACK_VOICE_ID;
      }

      async function requestMiniMaxTtsAudio(text, speaker, options = {}) {
        const apiKey = getMiniMaxApiKey();
        if (!apiKey) throw new Error("missing_api_key");

        const body = {
          model: MINIMAX_TTS_MODEL,
          text,
          stream: false,
          subtitle_enable: false,
          voice_setting: {
            voice_id: options.voiceId || getSpeakerVoiceId(speaker),
            speed: options.speed || 1,
            vol: 1,
            pitch: 0
          },
          audio_setting: {
            sample_rate: 32000,
            bitrate: 128000,
            format: "mp3",
            channel: 1
          }
        };

        const response = await fetch(`${MINIMAX_BASE_URL}/t2a_v2`, {
          method: "POST",
          headers: {
            Authorization: `Bearer ${apiKey}`,
            "Content-Type": "application/json"
          },
          body: JSON.stringify(body)
        });

        const data = await parseJsonSafe(response);
        const statusCode = data?.base_resp?.status_code;
        if (!response.ok || (typeof statusCode === "number" && statusCode !== 0)) {
          const message = data?.base_resp?.status_msg || data?.message || `MiniMax TTS 失败 (${response.status})`;
          throw new Error(message);
        }

        const audioRaw = String(data?.data?.audio || data?.audio || "");
        if (!audioRaw) throw new Error("MiniMax TTS 未返回音频数据");

        const format = String(data?.extra_info?.audio_format || data?.audio_format || "mp3").toLowerCase();
        const bytes = isHexAudio(audioRaw) ? hexToBytes(audioRaw) : base64ToBytes(audioRaw);
        const mimeType = format.includes("wav")
          ? "audio/wav"
          : format.includes("pcm")
            ? "audio/pcm"
            : "audio/mpeg";

        const blob = new Blob([bytes], { type: mimeType });
        return URL.createObjectURL(blob);
      }

      function speakByBrowser(text, options = {}) {
        if (!window.speechSynthesis || !window.SpeechSynthesisUtterance) {
          if (options.onend) options.onend();
          return null;
        }

        window.speechSynthesis.cancel();
        const utter = new SpeechSynthesisUtterance(text);
        utter.lang = "zh-CN";
        utter.rate = options.rate || 1;
        utter.pitch = options.pitch || 1;
        utter.volume = 1;
        const voice = pickChineseVoice();
        if (voice) utter.voice = voice;
        if (options.onstart) utter.onstart = options.onstart;
        if (options.onend) utter.onend = options.onend;
        if (options.onerror) utter.onerror = options.onerror;
        window.speechSynthesis.speak(utter);
        return utter;
      }

      async function speakText(text, options = {}) {
        const content = String(text || "").trim();
        if (!content) {
          if (options.onend) options.onend();
          return null;
        }

        const token = ++activeSpeakToken;
        haltSpeechPlayback();
        const speaker = options.speaker || "assistant";
        const apiKey = getMiniMaxApiKey();

        if (!apiKey) {
          return speakByBrowser(content, options);
        }

        try {
          const url = await requestMiniMaxTtsAudio(content, speaker, options);
          if (token !== activeSpeakToken) {
            URL.revokeObjectURL(url);
            return null;
          }

          minimaxAudioPlayer.pause();
          minimaxAudioPlayer.currentTime = 0;
          revokeMiniMaxAudioUrl();
          minimaxAudioUrl = url;
          minimaxAudioPlayer.src = url;

          if (options.onstart) {
            minimaxAudioPlayer.onplay = () => {
              if (token !== activeSpeakToken) return;
              options.onstart();
            };
          } else {
            minimaxAudioPlayer.onplay = null;
          }

          minimaxAudioPlayer.onended = () => {
            if (token !== activeSpeakToken) return;
            if (options.onend) options.onend();
          };

          minimaxAudioPlayer.onerror = () => {
            if (token !== activeSpeakToken) return;
            if (options.onerror) options.onerror(new Error("MiniMax 音频播放失败"));
            speakByBrowser(content, options);
          };

          await minimaxAudioPlayer.play();
          return { type: "minimax", token };
        } catch (error) {
          if (token !== activeSpeakToken) return null;
          if (options.onerror) options.onerror(error);
          return speakByBrowser(content, options);
        }
      }

      const setupStagePillar = document.getElementById("setup-stage-pillar");
      const setupStageRitual = document.getElementById("setup-stage-ritual");
      const setupQuestionEl = document.getElementById("setup-question");
      const setupProgressText = document.getElementById("setup-progress-text");
      const setupProgressFill = document.getElementById("setup-progress-fill");
      const setupPrevBtn = document.getElementById("setup-prev-btn");
      const setupNextBtn = document.getElementById("setup-next-btn");
      const setupAvatar = document.getElementById("setup-avatar");
      const setupRecordDot = document.getElementById("setup-record-dot");
      const setupRecordText = document.getElementById("setup-record-text");
      const avatarPicker = document.getElementById("avatar-picker");
      const avatarOptions = document.getElementById("avatar-options");
      const avatarAiPrompt = document.getElementById("avatar-ai-prompt");
      const avatarAiGenerateBtn = document.getElementById("avatar-ai-generate-btn");
      const avatarAiNote = document.getElementById("avatar-ai-note");

      const SpeechRecognitionClass = window.SpeechRecognition || window.webkitSpeechRecognition || null;
      let setupRecognizer = null;
      let setupListeningEnabled = false;
      let setupSpeechToken = 0;
      let modelingInProgress = false;

      let recorderStream = null;
      let recorderContext = null;
      let recorderSource = null;
      let recorderProcessor = null;
      let recorderSilentGain = null;
      let recorderBuffers = [];
      let recorderSampleRate = 16000;
      let recorderSampleCount = 0;
      let recordingTicker = null;

      const setupRecordingRuntime = {
        mainBlob: null,
        promptBlob: null,
        durationSec: 0
      };

      function updateRecordingBadge({ live = false, text = "等待录音" } = {}) {
        setupRecordDot.classList.toggle("live", live);
        setupRecordText.textContent = text;
      }

      function createRecognizer() {
        if (!SpeechRecognitionClass) return null;
        const recognition = new SpeechRecognitionClass();
        recognition.lang = "zh-CN";
        recognition.continuous = true;
        recognition.interimResults = true;
        recognition.maxAlternatives = 1;
        return recognition;
      }

      function currentSetupStep() {
        return setupFlow[state.setup.index];
      }

      function isQuestionStep(step) {
        return Boolean(step && step.type === "question");
      }

      function writeWavString(view, offset, str) {
        for (let i = 0; i < str.length; i += 1) {
          view.setUint8(offset + i, str.charCodeAt(i));
        }
      }

      function encodeWavBlob(floatData, sampleRate) {
        const byteRate = sampleRate * 2;
        const blockAlign = 2;
        const buffer = new ArrayBuffer(44 + floatData.length * 2);
        const view = new DataView(buffer);

        writeWavString(view, 0, "RIFF");
        view.setUint32(4, 36 + floatData.length * 2, true);
        writeWavString(view, 8, "WAVE");
        writeWavString(view, 12, "fmt ");
        view.setUint32(16, 16, true);
        view.setUint16(20, 1, true);
        view.setUint16(22, 1, true);
        view.setUint32(24, sampleRate, true);
        view.setUint32(28, byteRate, true);
        view.setUint16(32, blockAlign, true);
        view.setUint16(34, 16, true);
        writeWavString(view, 36, "data");
        view.setUint32(40, floatData.length * 2, true);

        let offset = 44;
        for (let i = 0; i < floatData.length; i += 1) {
          const sample = Math.max(-1, Math.min(1, floatData[i]));
          view.setInt16(offset, sample < 0 ? sample * 0x8000 : sample * 0x7fff, true);
          offset += 2;
        }

        return new Blob([buffer], { type: "audio/wav" });
      }

      function mergeBuffers(buffers, totalLength) {
        const data = new Float32Array(totalLength);
        let offset = 0;
        buffers.forEach((chunk) => {
          data.set(chunk, offset);
          offset += chunk.length;
        });
        return data;
      }

      function stopRecordingTicker() {
        clearInterval(recordingTicker);
        recordingTicker = null;
      }

      function startRecordingTicker() {
        stopRecordingTicker();
        recordingTicker = setInterval(() => {
          const sec = recorderSampleRate ? Math.floor(recorderSampleCount / recorderSampleRate) : 0;
          updateRecordingBadge({ live: true, text: `录音中 ${formatDuration(sec)}` });
        }, 500);
      }

      async function startSetupRecording() {
        if (recorderProcessor) return true;
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
          updateRecordingBadge({ live: false, text: "浏览器不支持录音" });
          return false;
        }

        try {
          recorderStream = await navigator.mediaDevices.getUserMedia({ audio: true });
          const AudioContextClass = window.AudioContext || window.webkitAudioContext;
          if (!AudioContextClass) {
            updateRecordingBadge({ live: false, text: "录音引擎不可用" });
            return false;
          }

          recorderContext = new AudioContextClass();
          recorderSampleRate = recorderContext.sampleRate;
          recorderSource = recorderContext.createMediaStreamSource(recorderStream);
          recorderProcessor = recorderContext.createScriptProcessor(4096, 1, 1);
          recorderSilentGain = recorderContext.createGain();
          recorderSilentGain.gain.value = 0;
          recorderBuffers = [];
          recorderSampleCount = 0;

          recorderProcessor.onaudioprocess = (event) => {
            const channel = event.inputBuffer.getChannelData(0);
            recorderBuffers.push(new Float32Array(channel));
            recorderSampleCount += channel.length;
          };

          recorderSource.connect(recorderProcessor);
          recorderProcessor.connect(recorderSilentGain);
          recorderSilentGain.connect(recorderContext.destination);

          startRecordingTicker();
          updateRecordingBadge({ live: true, text: "录音中 00:00" });
          return true;
        } catch {
          updateRecordingBadge({ live: false, text: "麦克风权限未开启" });
          return false;
        }
      }

      async function stopSetupRecording() {
        if (!recorderProcessor) return setupRecordingRuntime;

        try {
          recorderProcessor.disconnect();
          recorderSource.disconnect();
          recorderSilentGain.disconnect();
        } catch {}

        if (recorderStream) {
          recorderStream.getTracks().forEach((track) => track.stop());
        }

        if (recorderContext && recorderContext.state !== "closed") {
          try {
            await recorderContext.close();
          } catch {}
        }

        stopRecordingTicker();

        const merged = mergeBuffers(recorderBuffers, recorderSampleCount);
        const durationSec = recorderSampleRate ? recorderSampleCount / recorderSampleRate : 0;
        const mainBlob = merged.length ? encodeWavBlob(merged, recorderSampleRate) : null;
        const promptSamples = merged.slice(0, Math.min(merged.length, Math.floor(recorderSampleRate * 8)));
        const promptBlob = promptSamples.length ? encodeWavBlob(promptSamples, recorderSampleRate) : null;

        setupRecordingRuntime.mainBlob = mainBlob;
        setupRecordingRuntime.promptBlob = promptBlob;
        setupRecordingRuntime.durationSec = durationSec;

        state.setup.recordingDurationSec = durationSec;
        state.model.voiceClone.recordedDurationSec = durationSec;
        saveState();

        updateRecordingBadge({
          live: false,
          text: durationSec > 0 ? `已录制 ${formatDuration(durationSec)}` : "未录到有效音频"
        });

        recorderStream = null;
        recorderContext = null;
        recorderSource = null;
        recorderProcessor = null;
        recorderSilentGain = null;
        recorderBuffers = [];
        recorderSampleCount = 0;

        return setupRecordingRuntime;
      }

      async function ensureSetupRecording() {
        if (state.onboardingDone) return false;
        if (recorderProcessor) return true;
        return startSetupRecording();
      }

      function stopSetupListening() {
        setupListeningEnabled = false;
        if (setupRecognizer) {
          try {
            setupRecognizer.onend = null;
            setupRecognizer.stop();
          } catch {}
          setupRecognizer = null;
        }
      }

      async function startSetupListening() {
        const step = currentSetupStep();
        if (!isQuestionStep(step)) return;
        if (!SpeechRecognitionClass || currentScreen !== "setup") return;

        await ensureSetupRecording();
        stopSetupListening();
        setupListeningEnabled = true;

        const stepId = step.id;
        const recognition = createRecognizer();
        if (!recognition) return;

        setupRecognizer = recognition;

        recognition.onresult = (event) => {
          let finalText = "";
          for (let i = event.resultIndex; i < event.results.length; i += 1) {
            const piece = event.results[i][0].transcript.trim();
            if (event.results[i].isFinal && piece) {
              finalText += `${piece} `;
            }
          }

          if (!finalText) return;
          if (currentSetupStep().id !== stepId) return;

          const merged = `${state.setup.answers[stepId] || ""} ${finalText}`.trim();
          state.setup.answers[stepId] = merged.slice(0, 400);
          saveState();
          statusText.textContent = `创建助理采集中 · 已记录 ${step.pillar}`;
        };

        recognition.onerror = () => {
          statusText.textContent = `创建助理采集中 · ${state.setup.index + 1}/${setupFlow.length}`;
        };

        recognition.onend = () => {
          if (setupListeningEnabled && currentScreen === "setup" && currentSetupStep().id === stepId) {
            try {
              recognition.start();
            } catch {}
          }
        };

        try {
          recognition.start();
        } catch {}
      }

      function getCloneReadyText() {
        return state.model.voiceClone.status === "success"
          ? "人格完成 · MiniMax 声音可用"
          : "人格与语音建模已完成";
      }

      function selectAvatar(avatarId, source = "manual") {
        const avatar = avatarMap[avatarId];
        if (!avatar) return;
        state.selfProfile.avatarId = avatar.id;
        state.selfProfile.group = avatar.group;
        saveState();
        applySelfProfile();
        renderAvatarOptions();

        if (source === "ai") {
          avatarAiNote.textContent = `AI 已生成：${avatar.name}（${avatar.group.toUpperCase()}）`;
        } else {
          avatarAiNote.textContent = `已选择：${avatar.name}`;
        }
      }

      function renderAvatarOptions() {
        avatarOptions.innerHTML = "";
        avatarCatalog.forEach((avatar) => {
          const btn = document.createElement("button");
          btn.type = "button";
          btn.className = `avatar-option ${state.selfProfile.avatarId === avatar.id ? "active" : ""}`;
          btn.dataset.avatarId = avatar.id;
          btn.innerHTML = `
            <span class="avatar-chip" style="--avatar-a:${avatar.a}; --avatar-b:${avatar.b};"></span>
            <p>${avatar.name}</p>
          `;
          avatarOptions.appendChild(btn);
        });
      }

      function getAvatarByPrompt(prompt) {
        const text = (prompt || "").toLowerCase();
        const byGroup = {
          analysts: ["理性", "分析", "冷静", "逻辑"],
          diplomats: ["温暖", "共情", "治愈", "陪伴"],
          sentinels: ["稳", "秩序", "执行", "可靠"],
          explorers: ["创意", "活力", "冒险", "表达"]
        };

        let targetGroup = "";
        Object.entries(byGroup).forEach(([group, keywords]) => {
          if (targetGroup) return;
          if (keywords.some((word) => text.includes(word))) {
            targetGroup = group;
          }
        });

        const pool = targetGroup
          ? avatarCatalog.filter((item) => item.group === targetGroup)
          : avatarCatalog;
        return pool[Math.floor(Math.random() * pool.length)];
      }

      function promptSetupStep() {
        if (currentScreen !== "setup") return;
        const step = currentSetupStep();
        setupSpeechToken += 1;
        const token = setupSpeechToken;

        stopSetupListening();
        setAvatarState(setupAvatar, null, "thinking");

        if (!step) return;

        if (step.type === "avatar") {
          speakText("最后一步，请选择你的虚拟形象，也可以使用 AI 生成。", {
            speaker: "assistant",
            rate: 0.98,
            onstart: () => {
              if (token !== setupSpeechToken) return;
              setAvatarState(setupAvatar, null, "speaking");
              statusText.textContent = "仪式收束中 · 选择虚拟形象";
            },
            onend: () => {
              if (token !== setupSpeechToken) return;
              setAvatarState(setupAvatar, null, "idle");
            }
          });
          return;
        }

        const question = step.question;
        speakText(question, {
          speaker: "assistant",
          rate: 0.96,
          onstart: () => {
            if (token !== setupSpeechToken) return;
            setAvatarState(setupAvatar, null, "speaking");
            statusText.textContent = `创建助理提问中 · ${step.pillar}`;
          },
          onend: async () => {
            if (token !== setupSpeechToken || currentScreen !== "setup") return;
            setAvatarState(setupAvatar, null, "listening");
            statusText.textContent = `创建助理采集中 · ${state.setup.index + 1}/${setupFlow.length}`;
            await startSetupListening();
          }
        });
      }

      function renderSetupStep({ speak = false } = {}) {
        const step = currentSetupStep();
        if (!step) return;

        setupStagePillar.textContent = `TELOS · ${step.pillar}`;
        setupStageRitual.textContent = `仪式阶段 · ${step.ritual}`;
        setupProgressText.textContent = `${state.setup.index + 1} / ${setupFlow.length}`;
        setupProgressFill.style.width = `${((state.setup.index + 1) / setupFlow.length) * 100}%`;
        setupPrevBtn.disabled = state.setup.index === 0;
        setupNextBtn.textContent = state.setup.index === setupFlow.length - 1 ? "开始建模" : "下一题";

        if (step.type === "avatar") {
          setupQuestionEl.textContent = step.question;
          avatarPicker.classList.remove("hidden");
          stopSetupListening();
          setAvatarState(setupAvatar, null, "thinking");
          statusText.textContent = "采集最后一步 · 选择你的虚拟形象";
          renderAvatarOptions();
        } else {
          setupQuestionEl.textContent = step.question;
          avatarPicker.classList.add("hidden");
          statusText.textContent = `创建助理采集中 · ${state.setup.index + 1}/${setupFlow.length}`;
          if (state.setup.recordingDurationSec > 0 && !recorderProcessor) {
            updateRecordingBadge({
              live: false,
              text: `已录制 ${formatDuration(state.setup.recordingDurationSec)}`
            });
          }
        }

        saveState();
        if (speak) promptSetupStep();
      }

      setupPrevBtn.addEventListener("click", () => {
        if (state.setup.index === 0 || modelingInProgress) return;
        state.setup.index -= 1;
        renderSetupStep({ speak: true });
      });

      setupNextBtn.addEventListener("click", async () => {
        if (modelingInProgress) return;
        const step = currentSetupStep();
        if (!step) return;

        if (state.setup.index < setupFlow.length - 1) {
          state.setup.index += 1;
          renderSetupStep({ speak: true });
          return;
        }

        if (!state.selfProfile.avatarId) {
          selectAvatar("aurora");
        }

        setupPrevBtn.disabled = true;
        setupNextBtn.disabled = true;
        statusText.textContent = "封存语音样本中...";
        await stopSetupRecording();
        setAvatarState(setupAvatar, null, "speaking");
        statusText.textContent = "采集完成 · 准备建模";
        await runModeling();
      });

      avatarOptions.addEventListener("click", (event) => {
        const target = event.target;
        if (!(target instanceof HTMLElement)) return;
        const button = target.closest(".avatar-option");
        if (!button) return;
        const avatarId = button.dataset.avatarId;
        if (!avatarId) return;
        selectAvatar(avatarId, "manual");
      });

      avatarAiGenerateBtn.addEventListener("click", () => {
        const avatar = getAvatarByPrompt(avatarAiPrompt.value.trim());
        selectAvatar(avatar.id, "ai");
      });

      const modelTitle = document.getElementById("model-title");
      const modelSub = document.getElementById("model-sub");
      const modelPercent = document.getElementById("model-percent");
      const modelFill = document.getElementById("model-fill");
      const modelLog = document.getElementById("model-log");

      function appendModelLog(text, status = "done") {
        const item = document.createElement("li");
        item.textContent = text;
        if (status === "done") {
          item.classList.add("done");
        }
        modelLog.appendChild(item);
      }

      function setModelProgress(current, total, title, sub) {
        const value = Math.round((current / total) * 100);
        modelTitle.textContent = title;
        modelSub.textContent = sub;
        modelFill.style.width = `${value}%`;
        modelPercent.textContent = `${value}%`;
      }

      function buildHiddenModelFromAnswers() {
        const merged = questionStepIds
          .map((id) => state.setup.answers[id] || "")
          .join(" ")
          .trim();
        const text = merged || "目标明确，表达稳定，偏向务实执行。";

        let personaSummary = "重视目标牵引和长期一致性，偏好先关键后扩展。";
        if (text.includes("复盘") || text.includes("经历")) {
          personaSummary = "重视复盘和迭代，善于从真实经历中提炼行动原则。";
        }
        if (text.includes("价值") || text.includes("原则")) {
          personaSummary = "原则驱动，决策时优先保证长期价值与关系稳定。";
        }

        let voiceSummary = "语速中等、表达清晰，适合日常协作与复盘场景。";
        if (text.includes("效率") || text.includes("快速")) {
          voiceSummary = "语速偏快、结构直给，适合高密度任务推进。";
        }
        if (text.includes("陪伴") || text.includes("温暖")) {
          voiceSummary = "语调偏柔和，强调陪伴与稳定反馈。";
        }

        state.model.builtAt = new Date().toISOString();
        state.model.personaSummary = personaSummary;
        state.model.voiceSummary = voiceSummary;
        saveState();
      }

      function getMiniMaxApiKey() {
        return (state.integration.minimaxApiKey || "").trim();
      }

      async function parseJsonSafe(response) {
        try {
          return await response.json();
        } catch {
          return null;
        }
      }

      function getContactHistory(contactId) {
        return state.chat.historyByContact[contactId] || [];
      }

      function appendContactTurn(contactId, role, content) {
        const text = String(content || "").trim();
        if (!text) return;
        const safeRole = role === "assistant" ? "assistant" : "user";
        const current = getContactHistory(contactId);
        const next = [...current, { role: safeRole, content: text.slice(0, 800) }].slice(-16);
        state.chat.historyByContact[contactId] = next;
        saveState();
      }

      function buildMiniMaxChatMessages(contact, userText) {
        const history = getContactHistory(contact.id).slice(-10);
        const persona = state.model.personaSummary || "目标导向，先关键后扩展。";
        const voice = state.model.voiceSummary || "表达清晰，节奏稳定。";
        const style = styleLabels[state.selfProfile.style] || "平衡";
        const intro = `你正在模拟用户本人的数字人，用中文语音电话风格回复。`;
        const constraint = [
          "输出要求：",
          "1) 每次回复 1-3 句，先结论后建议。",
          "2) 可执行、具体，不要泛泛而谈。",
          "3) 语气与用户人格保持一致，避免机器人口吻。"
        ].join("\n");

        const systemPrompt = [
          intro,
          `人格摘要：${persona}`,
          `语音风格：${voice}`,
          `当前口吻偏好：${style}`,
          constraint
        ].join("\n");

        const telosContext = questionStepIds
          .map((id) => {
            const flow = setupFlow.find((item) => item.id === id);
            if (!flow) return "";
            const answer = state.setup.answers[id] || "";
            if (!answer.trim()) return "";
            return `${flow.pillar}: ${answer.trim()}`;
          })
          .filter(Boolean)
          .join("\n");

        const messages = [
          { role: "system", name: "数字人内核", content: systemPrompt },
          {
            role: "user_system",
            name: "TELOS-摘要",
            content: telosContext || "用户正在完成人格采集，优先给出稳健可执行建议。"
          },
          { role: "group", name: "场景", content: `电话对象: ${contact.name}` },
          { role: "sample_message_user", name: "示例用户", content: "我现在很乱，不知道先做什么。" },
          {
            role: "sample_message_ai",
            name: "示例数字人",
            content: "先只选一件今天必须完成的事，给它 45 分钟完整专注，然后再看下一步。"
          }
        ];

        history.forEach((turn) => {
          messages.push({
            role: turn.role === "assistant" ? "assistant" : "user",
            name: turn.role === "assistant" ? "数字人" : "用户",
            content: turn.content
          });
        });

        messages.push({
          role: "user",
          name: "用户",
          content: String(userText || "").trim()
        });

        return messages;
      }

      async function callMiniMaxChat(contact, userText) {
        const apiKey = getMiniMaxApiKey();
        if (!apiKey) throw new Error("missing_api_key");

        const payload = {
          model: MINIMAX_CHAT_MODEL,
          stream: false,
          temperature: 0.7,
          top_p: 0.9,
          max_completion_tokens: 220,
          messages: buildMiniMaxChatMessages(contact, userText)
        };

        const response = await fetch(`${MINIMAX_BASE_URL}/text/chatcompletion_v2`, {
          method: "POST",
          headers: {
            Authorization: `Bearer ${apiKey}`,
            "Content-Type": "application/json"
          },
          body: JSON.stringify(payload)
        });

        const data = await parseJsonSafe(response);
        const statusCode = data?.base_resp?.status_code;
        if (!response.ok || (typeof statusCode === "number" && statusCode !== 0)) {
          const message = data?.base_resp?.status_msg || data?.message || `对话失败 (${response.status})`;
          throw new Error(message);
        }

        const choice = data?.choices?.[0];
        if (choice?.message?.output_sensitive) {
          return "这个话题我先不展开，我们回到可执行的下一步。";
        }

        const reply = String(choice?.message?.content || "").trim();
        if (!reply) throw new Error("M2-her 未返回有效内容");
        return reply;
      }

      function createMiniMaxVoiceId() {
        const seed = state.selfProfile.name.replace(/[^a-zA-Z0-9]/g, "").slice(0, 10) || "VoiceTwin";
        return `V${seed}${Date.now()}`;
      }

      async function uploadMiniMaxFile(apiKey, blob, purpose, fileName) {
        const form = new FormData();
        form.append("purpose", purpose);
        form.append("file", blob, fileName);
        const response = await fetch(`${MINIMAX_BASE_URL}/files/upload`, {
          method: "POST",
          headers: {
            Authorization: `Bearer ${apiKey}`
          },
          body: form
        });
        const data = await parseJsonSafe(response);
        const statusCode = data?.base_resp?.status_code;
        if (!response.ok || (typeof statusCode === "number" && statusCode !== 0)) {
          const message = data?.base_resp?.status_msg || data?.message || `上传失败 (${response.status})`;
          throw new Error(message);
        }

        const fileId = data?.file?.file_id;
        if (!fileId) throw new Error("上传成功但未返回 file_id");
        return fileId;
      }

      async function callMiniMaxVoiceClone(apiKey, voiceId, mainFileId, promptFileId) {
        const body = {
          file_id: mainFileId,
          voice_id: voiceId,
          text: "你好，我是你的数字人分身。",
          model: "speech-2.8-hd",
          need_noise_reduction: true,
          need_volume_normalization: true
        };

        if (promptFileId) {
          body.clone_prompt = {
            prompt_audio: promptFileId,
            prompt_text: "你好，我是你的数字人分身。"
          };
        }

        const response = await fetch(`${MINIMAX_BASE_URL}/voice_clone`, {
          method: "POST",
          headers: {
            Authorization: `Bearer ${apiKey}`,
            "Content-Type": "application/json"
          },
          body: JSON.stringify(body)
        });

        const data = await parseJsonSafe(response);
        const statusCode = data?.base_resp?.status_code;
        if (!response.ok || (typeof statusCode === "number" && statusCode !== 0)) {
          const message = data?.base_resp?.status_msg || data?.message || `复刻失败 (${response.status})`;
          throw new Error(message);
        }

        return data;
      }

      function setVoiceCloneStatus(status, error = "") {
        state.model.voiceClone.status = status;
        state.model.voiceClone.error = error;
        state.model.voiceClone.updatedAt = new Date().toISOString();
        saveState();
        updateMiniMaxPanel();
      }

      async function runMiniMaxVoiceClone({ fromModel = false } = {}) {
        const apiKey = getMiniMaxApiKey();
        if (!apiKey) {
          if (!fromModel) setVoiceCloneStatus("failed", "请先填写 MiniMax API Key");
          return { status: "skipped", message: "未填写 MiniMax API Key" };
        }

        if (!setupRecordingRuntime.mainBlob) {
          setVoiceCloneStatus("failed", "未检测到本次采访音频，请重新完成一次采访采集");
          return { status: "failed", message: "未检测到采访音频" };
        }

        if (setupRecordingRuntime.durationSec < 10) {
          setVoiceCloneStatus("failed", "声音样本不足 10 秒，无法进行稳定复刻");
          return { status: "failed", message: "声音样本不足 10 秒" };
        }

        setVoiceCloneStatus("running");
        try {
          const mainFileId = await uploadMiniMaxFile(
            apiKey,
            setupRecordingRuntime.mainBlob,
            "voice_clone",
            "setup_voice.wav"
          );

          let promptFileId = "";
          if (setupRecordingRuntime.promptBlob) {
            promptFileId = await uploadMiniMaxFile(
              apiKey,
              setupRecordingRuntime.promptBlob,
              "prompt_audio",
              "setup_prompt.wav"
            );
          }

          const voiceId = createMiniMaxVoiceId();
          const cloneData = await callMiniMaxVoiceClone(apiKey, voiceId, mainFileId, promptFileId);
          state.model.voiceClone.status = "success";
          state.model.voiceClone.voiceId = voiceId;
          state.model.voiceClone.error = "";
          state.model.voiceClone.demoAudio = String(cloneData?.demo_audio || "");
          state.model.voiceClone.updatedAt = new Date().toISOString();
          saveState();
          updateMiniMaxPanel();
          return { status: "success", message: `voice_id: ${voiceId}` };
        } catch (error) {
          const message = error instanceof Error ? error.message : "声音复刻失败";
          setVoiceCloneStatus("failed", message);
          return { status: "failed", message };
        }
      }

      async function runModeling() {
        if (modelingInProgress) return;
        modelingInProgress = true;
        stopSetupListening();
        stopActiveTts();
        showScreen("model");
        statusText.textContent = "建模仪式进行中";
        modelLog.innerHTML = "";
        modelFill.style.width = "0%";
        modelPercent.textContent = "0%";

        buildHiddenModelFromAnswers();

        const ritualSteps = [
          {
            title: "展开 TELOS 星图",
            sub: "读取 MISSION / GOALS / BELIEFS",
            log: "核心使命与价值坐标完成锁定",
            delay: 900
          },
          {
            title: "注入认知模型",
            sub: "融合 MODELS / STRATEGIES",
            log: "决策偏好与执行策略完成映射",
            delay: 980
          },
          {
            title: "封存个人叙事",
            sub: "吸收 NARRATIVES / CHALLENGES / IDEAS",
            log: "个人叙事链路完成固化",
            delay: 950
          },
          {
            title: "拟合语音样本",
            sub: "提取音色、韵律与节奏特征",
            log: "基础声纹向量生成完成",
            delay: 900
          }
        ];

        const totalSteps = ritualSteps.length + 2;
        let stepCount = 0;

        for (const step of ritualSteps) {
          stepCount += 1;
          setModelProgress(stepCount, totalSteps, step.title, step.sub);
          await sleep(step.delay);
          appendModelLog(step.log, "done");
        }

        stepCount += 1;
        setModelProgress(stepCount, totalSteps, "启动 MiniMax 声音复刻", "上传采访音频并创建 voice_id");
        const cloneResult = await runMiniMaxVoiceClone({ fromModel: true });
        if (cloneResult.status === "success") {
          appendModelLog(`MiniMax 声音复刻成功 · ${cloneResult.message}`, "done");
        } else if (cloneResult.status === "skipped") {
          appendModelLog(`已跳过声音复刻 · ${cloneResult.message}`, "pending");
        } else {
          appendModelLog(`声音复刻失败 · ${cloneResult.message}`, "pending");
        }

        stepCount += 1;
        setModelProgress(stepCount, totalSteps, "完成人格校准", "输出可通话数字人");
        await sleep(820);
        appendModelLog("数字人初始化完成", "done");

        state.onboardingDone = true;
        saveState();

        modelTitle.textContent = "建模完成";
        modelSub.textContent = "正在打开数字人通讯录...";
        modelFill.style.width = "100%";
        modelPercent.textContent = "100%";
        statusText.textContent = "建模完成 · 打开通讯录";
        await sleep(900);
        modelingInProgress = false;
        openHome();
      }

      function getAllContacts() {
        const selfContact = {
          id: "self",
          name: state.selfProfile.name,
          sub: getCloneReadyText(),
          group: state.selfProfile.group
        };
        return [selfContact, ...state.contacts];
      }

      const contactList = document.getElementById("contact-list");
      const contactsCountTag = document.getElementById("contacts-count-tag");
      const addEntryBtn = document.getElementById("add-entry-btn");
      const settingsEntryBtn = document.getElementById("settings-entry-btn");

      const selfContactNameEl = document.getElementById("self-contact-name");
      const selfContactSubEl = document.getElementById("self-contact-sub");
      const selfContactAvatarEl = document.getElementById("self-contact-avatar");

      function applySelfProfile() {
        selfContactNameEl.textContent = state.selfProfile.name;
        selfContactSubEl.textContent = getCloneReadyText();
        const avatar = avatarMap[state.selfProfile.avatarId];
        const palette = avatar || groupPalette[state.selfProfile.group] || groupPalette.analysts;
        selfContactAvatarEl.style.setProperty("--contact-a", palette.a);
        selfContactAvatarEl.style.setProperty("--contact-b", palette.b);
      }

      function renderContacts() {
        contactList.innerHTML = "";
        contactsCountTag.textContent = String(state.contacts.length);

        state.contacts.forEach((contact) => {
          const palette = groupPalette[contact.group] || groupPalette.sentinels;
          const row = document.createElement("div");
          row.className = "contact-item";
          row.innerHTML = `
            <div class="contact-left">
              <div class="contact-avatar" style="--contact-a:${palette.a}; --contact-b:${palette.b};"></div>
              <div>
                <p class="contact-name">${contact.name}</p>
                <p class="contact-sub">${contact.sub}</p>
              </div>
            </div>
            <button class="mini-call" data-contact-id="${contact.id}">语音电话</button>
          `;
          contactList.appendChild(row);
        });
      }

      function openHome() {
        applySelfProfile();
        renderContacts();
        showScreen("home");
        statusText.textContent = "通讯录首页 · 可随时发起语音电话";
      }

      addEntryBtn.addEventListener("click", () => {
        showScreen("add");
        statusText.textContent = "添加数字人";
      });

      settingsEntryBtn.addEventListener("click", () => {
        document.getElementById("update-name-input").value = state.selfProfile.name;
        document.getElementById("update-style-select").value = state.selfProfile.style;
        document.getElementById("share-code-output").value = state.selfProfile.shareCode;
        minimaxApiKeyInput.value = state.integration.minimaxApiKey;
        updateMiniMaxPanel();
        showScreen("settings");
        statusText.textContent = "我的数字人设置";
      });

      const addIdInput = document.getElementById("add-id-input");
      const addIdConfirmBtn = document.getElementById("add-id-confirm-btn");
      const addIdBackBtn = document.getElementById("add-id-back-btn");
      const addIdFeedback = document.getElementById("add-id-feedback");

      addIdConfirmBtn.addEventListener("click", () => {
        const rawId = addIdInput.value.trim();
        if (!rawId) {
          addIdFeedback.textContent = "请输入有效的数字 ID。";
          return;
        }

        const normalizedId = rawId.toLowerCase();
        if (normalizedId === state.selfProfile.digitalId.toLowerCase()) {
          addIdFeedback.textContent = "这是你自己的数字 ID，无需重复添加。";
          return;
        }

        const exists = state.contacts.some((item) => item.id === normalizedId);
        if (exists) {
          addIdFeedback.textContent = "该数字 ID 已存在于通讯录。";
          return;
        }

        const groups = ["analysts", "diplomats", "sentinels", "explorers"];
        const codeSum = [...normalizedId].reduce((acc, ch) => acc + ch.charCodeAt(0), 0);
        const group = groups[codeSum % groups.length];

        state.contacts.push({
          id: normalizedId,
          name: `数字人 ${rawId}`,
          sub: `来自 ID: ${rawId}`,
          group
        });

        saveState();
        renderContacts();
        addIdFeedback.textContent = `已添加数字人: ${rawId}`;
        addIdInput.value = "";
      });

      addIdBackBtn.addEventListener("click", openHome);

      const queryProfileBtn = document.getElementById("query-profile-btn");
      const queryProfileResult = document.getElementById("query-profile-result");
      const updateNameInput = document.getElementById("update-name-input");
      const updateStyleSelect = document.getElementById("update-style-select");
      const saveProfileBtn = document.getElementById("save-profile-btn");
      const saveProfileResult = document.getElementById("save-profile-result");
      const shareCodeOutput = document.getElementById("share-code-output");
      const genShareCodeBtn = document.getElementById("gen-share-code-btn");
      const copyShareCodeBtn = document.getElementById("copy-share-code-btn");
      const shareResult = document.getElementById("share-result");
      const settingsBackBtn = document.getElementById("settings-back-btn");
      const minimaxApiKeyInput = document.getElementById("minimax-api-key-input");
      const minimaxVoiceId = document.getElementById("minimax-voice-id");
      const minimaxCloneBtn = document.getElementById("minimax-clone-btn");
      const minimaxCloneStatus = document.getElementById("minimax-clone-status");
      const minimaxDemoAudio = document.getElementById("minimax-demo-audio");

      function updateMiniMaxPanel() {
        const cloneState = state.model.voiceClone;
        const voiceId = cloneState.voiceId || "未生成";
        minimaxVoiceId.textContent = `voice_id: ${voiceId}`;

        const statusMap = {
          idle: "未执行",
          running: "声音复刻中...",
          success: "声音复刻成功",
          failed: `声音复刻失败: ${cloneState.error || "未知错误"}`
        };
        const durationNote =
          cloneState.recordedDurationSec > 0
            ? ` · 采样 ${formatDuration(cloneState.recordedDurationSec)}`
            : "";
        minimaxCloneStatus.textContent = `${statusMap[cloneState.status] || cloneState.status}${durationNote}`;

        if (cloneState.demoAudio) {
          minimaxDemoAudio.src = cloneState.demoAudio;
          minimaxDemoAudio.classList.remove("hidden");
        } else {
          minimaxDemoAudio.removeAttribute("src");
          minimaxDemoAudio.classList.add("hidden");
        }
      }

      minimaxApiKeyInput.addEventListener("change", () => {
        state.integration.minimaxApiKey = minimaxApiKeyInput.value.trim();
        saveState();
        updateMiniMaxPanel();
      });

      minimaxCloneBtn.addEventListener("click", async () => {
        minimaxCloneBtn.disabled = true;
        statusText.textContent = "正在执行 MiniMax 声音复刻";
        await runMiniMaxVoiceClone({ fromModel: false });
        updateMiniMaxPanel();
        statusText.textContent = "我的数字人设置";
        minimaxCloneBtn.disabled = false;
      });

      queryProfileBtn.addEventListener("click", () => {
        const builtAt = state.model.builtAt
          ? new Date(state.model.builtAt).toLocaleString("zh-CN")
          : "未建模";
        queryProfileResult.textContent = `ID: ${state.selfProfile.digitalId} · 名称: ${state.selfProfile.name} · 风格: ${styleLabels[state.selfProfile.style]} · 建模: ${builtAt}`;
      });

      saveProfileBtn.addEventListener("click", () => {
        const nextName = updateNameInput.value.trim();
        const nextStyle = updateStyleSelect.value;
        if (!nextName) {
          saveProfileResult.textContent = "显示名称不能为空。";
          return;
        }

        state.selfProfile.name = nextName;
        state.selfProfile.style = nextStyle;
        saveState();
        applySelfProfile();
        saveProfileResult.textContent = "已更新你的数字人信息。";
      });

      genShareCodeBtn.addEventListener("click", () => {
        const rand = Math.floor(1000 + Math.random() * 9000);
        state.selfProfile.shareCode = `VT-SHARE-${rand}`;
        shareCodeOutput.value = state.selfProfile.shareCode;
        saveState();
        shareResult.textContent = "已生成新的分享码。";
      });

      copyShareCodeBtn.addEventListener("click", async () => {
        const value = shareCodeOutput.value;
        try {
          if (navigator.clipboard && navigator.clipboard.writeText) {
            await navigator.clipboard.writeText(value);
            shareResult.textContent = "分享码已复制。";
            return;
          }
        } catch {}
        shareResult.textContent = `请手动复制: ${value}`;
      });

      settingsBackBtn.addEventListener("click", openHome);

      const callTitle = document.getElementById("call-title");
      const callSub = document.getElementById("call-sub");
      const callAvatar = document.getElementById("call-avatar");
      const callAvatarMeta = document.getElementById("call-avatar-meta");
      const callCaption = document.getElementById("call-caption");
      const callTimerEl = document.getElementById("call-timer");
      const callStateEl = document.getElementById("call-state");
      const hangupBtn = document.getElementById("hangup-btn");
      const callWaveBars = buildWave(document.getElementById("call-wave"), 24);

      let activeContact = null;
      let callActive = false;
      let callWaveTimer = null;
      let callDurationTimer = null;
      let callDurationSec = 0;
      let callRecognizer = null;
      let callRecognitionEnabled = false;
      let callFallbackTimer = null;
      let callSilenceTimer = null;
      let speakingNow = false;

      const fallbackUserPrompts = [
        "今天我该先做哪件事？",
        "请帮我把目标收敛到三个步骤。",
        "我想要更稳的执行节奏。"
      ];

      const fallbackReplySeed = {
        self: [
          "先把最关键的一步跑通，再做体验优化。",
          "你现在最需要的是确定优先级，然后连续推进。"
        ],
        planner: [
          "建议顺序是：关键任务、验证结果、最后复盘沉淀。",
          "先拆成必须完成和可选优化两层，执行会更稳。"
        ],
        coach: [
          "今天结束前记三件事：完成项、卡点、明天第一步。",
          "每轮任务结束后做 5 分钟复盘，会明显提效。"
        ],
        creator: [
          "先说结论再补两条依据，表达会更有说服力。",
          "你可以先口述结构，再补充细节内容。"
        ]
      };

      let callGeneratingReply = false;
      const callPendingInputs = [];

      function generateFallbackReply(userText, contact) {
        const clean = (userText || "").trim();
        const persona = state.model.personaSummary || "以目标为导向，先关键后优化。";
        const voice = state.model.voiceSummary || "语气平稳，结构清晰。";
        const list = fallbackReplySeed[contact.id] || fallbackReplySeed.self;

        if (!clean) {
          return `${list[0]} ${persona}`;
        }
        if (clean.includes("优先") || clean.includes("先做")) {
          return `${list[0]} 当前建议：先聚焦单点突破，再逐步扩展。`;
        }
        if (clean.includes("复盘") || clean.includes("总结")) {
          return `${list[1]} 你的人格偏好是“行动后快速复盘”。`;
        }
        if (clean.includes("表达") || clean.includes("口播")) {
          return `给你一个表达模板：一句结论 + 两条理由 + 一步行动。${voice}`;
        }
        return `${list[Math.floor(Math.random() * list.length)]} ${persona}`;
      }

      async function generateModelReply(userText, contact) {
        const apiKey = getMiniMaxApiKey();
        if (!apiKey) {
          return generateFallbackReply(userText, contact);
        }

        try {
          return await callMiniMaxChat(contact, userText);
        } catch {
          return generateFallbackReply(userText, contact);
        }
      }

      function clearCallTimers() {
        clearInterval(callWaveTimer);
        clearInterval(callDurationTimer);
        clearInterval(callFallbackTimer);
        clearTimeout(callSilenceTimer);
        callWaveTimer = null;
        callDurationTimer = null;
        callFallbackTimer = null;
        callSilenceTimer = null;
      }

      function stopCallRecognition() {
        callRecognitionEnabled = false;
        if (callRecognizer) {
          try {
            callRecognizer.onend = null;
            callRecognizer.stop();
          } catch {}
          callRecognizer = null;
        }
      }

      function scheduleSilencePing() {
        clearTimeout(callSilenceTimer);
        callSilenceTimer = setTimeout(() => {
          if (!callActive || speakingNow || !activeContact || callGeneratingReply || callPendingInputs.length) return;
          const reminder = "我在听，你可以继续说。";
          callCaption.textContent = `实时转写: ${reminder}`;
          speakText(reminder, {
            speaker: "digital",
            rate: 1,
            onstart: () => {
              speakingNow = true;
              setAvatarState(callAvatar, callAvatarMeta, "speaking", `${activeContact.name} 在回应`);
              callStateEl.textContent = "对方正在说话";
            },
            onend: () => {
              speakingNow = false;
              setAvatarState(callAvatar, callAvatarMeta, "listening", `${activeContact.name} 正在聆听`);
              callStateEl.textContent = "正在聆听你说话";
            }
          });
        }, 9000);
      }

      function queueUserInput(userText) {
        const text = String(userText || "").trim();
        if (!text) return;
        callPendingInputs.push(text);
        processReplyQueue();
      }

      async function processReplyQueue() {
        if (!callActive || !activeContact) return;
        if (callGeneratingReply || speakingNow) return;
        if (!callPendingInputs.length) return;

        const userText = callPendingInputs.shift();
        if (!userText) return;
        callGeneratingReply = true;

        appendContactTurn(activeContact.id, "user", userText);
        setAvatarState(callAvatar, callAvatarMeta, "thinking", `${activeContact.name} 正在思考`);
        callStateEl.textContent = `${MINIMAX_CHAT_MODEL} 推理中`;
        callCaption.textContent = `实时转写: ${userText}`;

        const response = await generateModelReply(userText, activeContact);
        appendContactTurn(activeContact.id, "assistant", response);
        callCaption.textContent = `实时转写: ${response}`;

        await speakText(response, {
          speaker: "digital",
          rate: 1,
          onstart: () => {
            speakingNow = true;
            setAvatarState(callAvatar, callAvatarMeta, "speaking", `${activeContact.name} 在回答`);
            callStateEl.textContent = "对方正在说话";
          },
          onend: () => {
            speakingNow = false;
            setAvatarState(callAvatar, callAvatarMeta, "listening", `${activeContact.name} 正在聆听`);
            callStateEl.textContent = "正在聆听你说话";
          }
        });

        callGeneratingReply = false;
        scheduleSilencePing();
        if (callPendingInputs.length) {
          processReplyQueue();
        }
      }

      function respondToUser(userText) {
        queueUserInput(userText);
      }

      function startCallFallback() {
        let idx = 0;
        clearInterval(callFallbackTimer);
        callFallbackTimer = setInterval(() => {
          if (!callActive || speakingNow || callGeneratingReply || callPendingInputs.length) return;
          const prompt = fallbackUserPrompts[idx % fallbackUserPrompts.length];
          idx += 1;
          callCaption.textContent = `实时转写: ${prompt}`;
          respondToUser(prompt);
        }, 12000);
      }

      function startCallRecognition() {
        if (!SpeechRecognitionClass || !callActive) {
          startCallFallback();
          return;
        }

        stopCallRecognition();
        callRecognitionEnabled = true;
        const recognition = createRecognizer();
        if (!recognition) {
          startCallFallback();
          return;
        }

        callRecognizer = recognition;
        recognition.onresult = (event) => {
          let interim = "";
          let finalText = "";
          for (let i = event.resultIndex; i < event.results.length; i += 1) {
            const piece = event.results[i][0].transcript.trim();
            if (!piece) continue;
            if (event.results[i].isFinal) {
              finalText += `${piece} `;
            } else {
              interim += `${piece} `;
            }
          }

          const preview = (finalText || interim).trim();
          if (preview) {
            callCaption.textContent = `实时转写: ${preview}`;
            callStateEl.textContent = "正在聆听你说话";
            setAvatarState(callAvatar, callAvatarMeta, "listening", `${activeContact.name} 正在聆听`);
            scheduleSilencePing();
          }

          if (finalText.trim()) {
            setTimeout(() => respondToUser(finalText.trim()), 550);
          }
        };

        recognition.onerror = () => {
          if (!callActive) return;
          callStateEl.textContent = "语音识别波动，自动重连中";
        };

        recognition.onend = () => {
          if (callRecognitionEnabled && callActive) {
            try {
              recognition.start();
            } catch {
              startCallFallback();
            }
          }
        };

        try {
          recognition.start();
        } catch {
          startCallFallback();
        }
      }

      function startCallSession() {
        if (!activeContact || callActive) return;
        callPendingInputs.length = 0;
        callGeneratingReply = false;
        callActive = true;
        ensureMic();

        callDurationSec = 0;
        callTimerEl.textContent = "00:00";
        callStateEl.textContent = "语音通话已接通";
        statusText.textContent = `与 ${activeContact.name} 通话中 · 00:00`;

        callWaveTimer = setInterval(() => animateWave(callWaveBars), 220);
        callDurationTimer = setInterval(() => {
          callDurationSec += 1;
          const t = formatDuration(callDurationSec);
          callTimerEl.textContent = t;
          statusText.textContent = `与 ${activeContact.name} 通话中 · ${t}`;
        }, 1000);

        setAvatarState(callAvatar, callAvatarMeta, "speaking", `${activeContact.name} 已接通`);
        speakText("我在，告诉我你现在最想推进的事情。", {
          speaker: "digital",
          rate: 1,
          onstart: () => {
            speakingNow = true;
            callStateEl.textContent = "对方正在说话";
          },
          onend: () => {
            speakingNow = false;
            setAvatarState(callAvatar, callAvatarMeta, "listening", `${activeContact.name} 正在聆听`);
            callStateEl.textContent = "正在聆听你说话";
            startCallRecognition();
            scheduleSilencePing();
          }
        });
      }

      function stopCallSession() {
        if (!callActive) {
          callPendingInputs.length = 0;
          callGeneratingReply = false;
          stopActiveTts();
          clearCallTimers();
          stopCallRecognition();
          setWaveIdle(callWaveBars);
          return;
        }

        callActive = false;
        speakingNow = false;
        callPendingInputs.length = 0;
        callGeneratingReply = false;
        clearCallTimers();
        stopCallRecognition();
        stopActiveTts();
        setWaveIdle(callWaveBars);
        callStateEl.textContent = "通话已结束";

        if (activeContact) {
          setAvatarState(callAvatar, callAvatarMeta, "idle", `${activeContact.name} 已离线`);
        } else {
          setAvatarState(callAvatar, callAvatarMeta, "idle", "待机中");
        }
      }

      function openCall(contactId) {
        const target = getAllContacts().find((item) => item.id === contactId);
        if (!target) return;
        callPendingInputs.length = 0;
        callGeneratingReply = false;
        activeContact = target;
        showScreen("call");
        callTitle.textContent = `与 ${target.name} 通话中`;
        callSub.textContent = "语音实时接通";
        callTimerEl.textContent = "00:00";
        callStateEl.textContent = "语音通话已接通";
        callCaption.textContent = "实时转写: 通话已接通...";
        setTimeout(startCallSession, 360);
      }

      hangupBtn.addEventListener("click", () => {
        stopCallSession();
        activeContact = null;
        openHome();
      });

      document.addEventListener("click", (event) => {
        const target = event.target;
        if (!(target instanceof HTMLElement)) return;
        const id = target.dataset.contactId;
        if (!id) return;
        openCall(id);
      });

      function bootstrap() {
        applySelfProfile();
        renderContacts();
        setWaveIdle(callWaveBars);
        updateMiniMaxPanel();

        if (state.onboardingDone) {
          openHome();
          updateRecordingBadge({
            live: false,
            text:
              state.setup.recordingDurationSec > 0
                ? `已录制 ${formatDuration(state.setup.recordingDurationSec)}`
                : "等待录音"
          });
          return;
        }

        showScreen("setup");
        renderSetupStep({ speak: speechReady });
        setAvatarState(setupAvatar, null, "listening");
        if (state.setup.recordingDurationSec > 0) {
          updateRecordingBadge({
            live: false,
            text: `已录制 ${formatDuration(state.setup.recordingDurationSec)}`
          });
        } else {
          updateRecordingBadge({ live: false, text: "等待录音" });
        }
      }

      bootstrap();
    </script>
  </body>
</html>
